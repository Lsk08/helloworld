### 深入理解Jvm ch2 Jvm内存 note
* JVM运行时数据区
    * PC计数器
        * 指向下一条运行的字节码指令
        * 线程私有
        * java方法对应当前字节码的内存地址 native方法对应null
        【native方法不在jvm里，而在本地接口库里】
        * 唯一一个没有OutOfMemory的区域
        
    * 虚拟机栈    
        * 线程私有，对应于方法的执行
        * 执行每个方法创建一个栈帧(stack frame)，储存【局部变量表】、 操作数栈、 动态链接、【方法出口】
        * 方法调用到返回对应着 栈帧【入栈】到【出栈】的过程
        * 局部变量表
            * 编译时确定空间
            * 基本类型、对象、返回类型
            * long 和 double 占用 2 个 slot 其余 1 slot
        * 异常 stackoverflow 和 outofmemory
        
    * 堆
        * 对象占用的区域
        * 垃圾回收的 【新生代】和【老生代】
        * 线程的本地私有区 TLAB
        * OutOfMemory
        
    * 方法区
        * 类信息、常量、静态变量
        * CG的永久代
        
    * 运行常量池
        * 包含在方法区内部
        * 字面常量和符号引用
        * 常量可以动态产生
        * OutOfMemory
        
    * 直接内存
        * 不属于Jvm和Java的规范
        * 在Nio中的DirectByteBuffer使用 避免了二次拷贝【jvm的堆和native的内存】
        
* 对象的创建  java代码的new指令
    * jvm从【运行常量池】定位对应的符号变量并检查对应的类是否被加载，否则先进行【类加载】
        * 可以看出JVM的类加载出现在【第一次创建该类时，并且只加载一次】
    * 分配内存
        * 对象的大小在创建时就可以确定
        * 根据分配的策略分为 【指针碰撞】 和 【空闲列表】，也就是内存是否连续分配
        * 根据多线程策略分为 【CAS更新】 和 【本地线程分配缓存TLAB】
        * 给字段赋零值 0、null
            * 也就是 对象可以不赋初值也可以使用
    * 创建对象头
        * 包括类的元数据信息【对象的类型】、哈希码、对象CG分代信息、锁状态【对象是否被锁定】、线程锁、偏向线程ID等等
    * 调用init 方法初始化字段
    
* 对象的内存布局   对象头+实例数据+padding
    * 对象头有【2】大内容
        * 类型指针，指向对象的类型，由此确定对象的类型
            * 对于数组的长度储存在对象头
        * 运行时信息，哈希码、CG代分、锁状态、线程持有锁、偏向线程ID
        
    * 实例数据
        * 包括父类和子类，相同长度的类型分配到一起，但是顺序受到具体策略的影响
        
    * 填充字段
        * 保证实例部分必须是8字节的倍数 【对象头只有32bit和64bit已经自动保存】
        
* 对象的访问定位
    * 2种方式
        * 【句柄】 对象的引用持有一个句柄，通过句柄索引对象的地址和对象的类型
        * 【直接】 对象的引用持有对象地址，对象头索引对象的类型
        * Hot spot 第二种，有点 只需要一次索引开销
        
* JVM调优  除了PC不会报错
    * 堆 -Xms 200M【小】 -Xmx 300M【大】
        * 异常 OutOfMemory java heap space 内存溢出/memory leak 内存泄漏
            * heap space 调整-Xms -Xmx 或者 持有过多对象
            * memory leak 掌握泄漏对象 和 CG ROOTS的关系，查明为什么不能回收该对象
            
    * 栈 -Xss 栈大小
        * 单线程只会StackOverFlow 多线程会有 OutOfMemory
        * StackOverFlow 一般不会出现、而且可以通过定位到具体的方法解决
        * OutOfMemory 可能出现在多线程中、由于没有内存分配给线程，可以通过减小堆内存和减小栈容量来换取多线程
        【当然可以增加物理内存或者使用64bit的系统和虚拟机】
        
    * 方法区和运行时常量池溢出  【 -XX:PermSize 和 -XX:MaxPermSize 】
        * 出现提示 OutOfMemory: PermGen Space
        * 运行时常量池位于方法区内，在JDK 6 以前属于永久代Perm 所以过多的常量也会导致 OutOfMemory 
        * 另外 方法区保存了class信息，而对于PermGen的垃圾回收条件极其苛刻，所以产生大量的类信息也会造成OutOfMemory
            * 例如，大量的动态类cglib、spring AOP、jsp等等
            
    * 直接内存溢出 -XX：MaxDirectMemorySize
        * 由Unsafe.allocateMemory()分配 
        * 特征 Dump 文件很小，但是有引用了nio就有可能发生
        
#### 可以看出 CG的垃圾回收就是在Jvm的【堆】和 【方法区】负责回收内存 和 【创建对象】、【类加载】对应

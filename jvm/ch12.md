### 并发
* 硬件
    * 在处理器和内存之间加入高速缓存和一致性协议，保证运算效率
        * 处理器 --> 高速缓存 --> 缓存一致性协议 --> 内存
    * 指令重排 【这里是CPU的指令重排。但是JIT的优化编译也有自己的指令重排】
    
* Java 工作内存 和 主内存
    * Java 模拟硬件也定义了一套内存模型
        * 线程 --> 工作内存 --> save & load 操作 --> 主内存
        * 线程对于变量的所有操作，例如读、写，都【必须】在工作线程完成，然后同步到主内存
        不允许直接访问主内存，而且工作内存之间不能相互访问
        
* 注意区分 Java内存模型和JVM运行时内存区域 
    * Java内存模型 定义了变量访问规则，即如何把变量储存到内存和如何从内存读取变量 意在屏蔽底层操作系统的差异
    类比于 处理器 和 内存的关系
    * JVM内存区域是 JVM运行时数据区
        
* Java 内存模型JMM 的8种操作 部分 原子性、顺讯性、可见性 都由这个内存模型来支持

    * 所有操作都是 【原子性】
    * 操作之间有顺序要求 【happens before原则】
    * 同一个变量，一次只能有一个线程执行Lock操作，但是可以多次lock，然后进行多个unlock才能解锁 【可重入锁】
    * 一个变量必须先执行lock，才能unlock 【对应于ReentrantLock.unlock() 的 IllegalMonitorStateException】
    * Lock 操作必须使用 load、assign 也就是清空工作内存，从主存重新读取变量到工作内存 【可见性】
    * unlock 之前，必须把工作内存同步到主内存 【可见性】
    
* volatile 
    * 可见性 但是不保证原子性
    * 禁止指令重排优化 
        * 底层由CPU对于依赖指令不重排决定
        
* Java的线程围绕原子性、可见性、有序性来展开

* Java中的线程是内核线程 也就是 线程操作需要在用户空间和系统内核切换 并且 线程数量有限 1:1【每一个java线程对应一个内核线程】
 所以创建销毁线程非常消耗系统资源 并且有内存限制
* Java中线程调度【给线程分配CPU的使用权】也是通过CPU决定 【抢占式】 所以线程的执行顺序不确定
* 线程的5种状态
    * NEW 新建
    * RUNNABLE 运行
    * WAITING 无限期等待 
        * wait、join、park
    * TIMED_WAITING 有限期等待
        * sleep、wait(ms)、join(ms)、parkNanos(ms)、parkUtil(ms)
    * BLOCKED 阻塞
        * sync、lock

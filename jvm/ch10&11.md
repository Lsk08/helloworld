### JVM编译器
* 【前端编译器】 把java编译成class文件，例如 Sun的Javac Eclipse的ECJ
* 【即时编译器JIT】 把class文件编译成机器码， 例如 HotSpot的C1、C2编译器
* 前端编译器主要优化【编码过程】，例如 语法糖   即时编译器主要优化【性能】，例如方法内联

### 前端编译器  从 词法分析 到 语义分析 到字节码生成 然后【解释】执行
* 解析与填充符号表
    * 词法、语法分析
        * 分析代码流，以token划分最小单位，生成抽象语法树
    * 符号填充表
        * K-V结构或者树形结构，保存符号和对应的内容信息，例如 类型、值，为之后的过程做准备，例如 【语义分析】
* 注解处理器
* 语义分析和字节码生成
    * 标注检查  语义检查1 局部检查 例如 类型是否匹配、变量是否声明
    * 数据及控制流分析   语义检查2 上下文检查 例如，每条路径是否有返回值  异常是否处理  
    * 解语法糖      例如 泛型、自动装箱、变长参数
    * 字节码生成  少量的代码整合
        * 字节码!=机器码  字节码是jvm运行的代码，与本地无关 而机器码是CPU直接运行的指令集，与本机系统有关
        
### 解释执行 与 编译执行
* 解释执行 有更快的启动速度和节约空间
* 编译执行 有更高的效率和动态优化 也就是【热点优化】
* HotSpot 采用混合模式，根据不同的情景可以互相切换

### 编译执行
* 编译触发基于 【热点探测】

* 热点探测
    * 基于栈顶的探测
    * 基于计数器的探测 HotSpot
    
* 编译优化技术  建立在 从字节码转化到机器码的过程中，也就是首先要触发【即时编译】
    * 公因子表达式消除
        * 语言无关   如果一个表达式被计算过 并且 所有变量的值没有变化 就不用计算 ，直接使用
    * 数组范围检查
        * 语言无关 隐士异常处理 保证正常状态的效率
         * 或者 编译检查
    * 方法内联
        * 由于java方法的动态加载，必须利用CHA【继承关系分析】做虚方法分析，只有虚方法只有一个版本才可以内联 当然非虚方法不受影响
    * 逃逸分析
        * 为其他优化方法提供分析，分为方法逃逸和线程逃逸
        * 如果一个对象没有方法或者线程逃逸 就可以做一些相应的优化
            * 栈上分配 如果对象没有方法逃逸 就可以分配到栈上 方便回收
            * 同步擦除 如果一个对象没有线程逃逸 就可以擦除掉同步措施
            * 标量替换 将可拆分对象 

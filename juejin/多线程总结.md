###  并发开发
* 并发开发的问题围绕 【竞争】 和 【协作】 而 他们又来源于 【内存共享】
* 线程管理是复杂的 所以java提供了许多工具类 比如并发容器、异步任务、线程池来帮助管理

* 线程安全机制 
    * 线程安全的两个方面 竞态条件(时序性) 和 可见性
        * 竞态条件 多个线程访问同一个对象 最终执行结果与执行时序有关
    * 方法 
        1. 使用synchronzied
            * 简单易用 性能自动优化
            * 同时解决 竞态条件和可见性 
            * 但是阻塞 不响应中断 会死锁
            * 只对同一个对象的多线程保护安全，例如 当前实例或者xx.class
        2. 显式锁 lock
            * 可以非阻塞、响应中断、限时更加灵活
            * 对于读多写少的场合可以 使用 ReentrantReadWriteLock
        3. 使用volatile
            * 只能保证可见性 但是没有线程切换的消耗
            * 原子操作，且在当前内容不依赖之前的值
        4. 使用原子变量和 CAS
            * 在set的值依赖于之前的值 但是同步内容比较简单可以考虑原子变量
            * CAS 比较并设置 是原子变量的基础 由计算机底层支持
            * CAS 是实现高效、非阻塞、乐观并发机制的基础 它也是并发包中锁、同步工具和各种容器的基础。(乐观锁的基础)
        5. 不可变(写复制)
        6. ThreadLocal
        
* 线程协作
    1. wait/notify
        * 需要配合sync使用 
        * 对象锁 等待队列 条件队列
    2. 显示条件 
        * 多个等待队列 简化代码
    3. 线程中断
        * 线程的中断是一种协作机制 需要由调用者处理相应的中断信号
    4. 协作工具
        * Semaphore、CountDownLatch、CyclicBarrier
    5. 阻塞队列
        * 常见于生成/消费者模式 封装了锁和条件
        * 基于数组的ArrayBlockingQueue、基于链表的LinkedBlockingQueue/LinkedBlockingDeque、
        基于堆的PriorityBlockingQueue 和 特殊场合的SynchronousQueue
    6. 异步任务
        * Future/FutureTask 分类任务本身、线程和管理工具 开发跟加简便
